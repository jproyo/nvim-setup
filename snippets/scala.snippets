# Adapted from: https://github.com/honza/vim-snippets

# Cats imports
snippet cats
  import cats._, cats.data._, cats.implicits._
  import cats.effect._, cats.effect.implicits._
  import fs2._, fs2.io._

# Finite duration
snippet dur
  import scala.concurrent.duration._

#if
snippet if
	if (${1})
		${0:${VISUAL}}


#if not
snippet ifn
	if (!${1})
		${0:${VISUAL}}


#if-else
snippet ife
	if (${1})
		${2:${VISUAL}}
	else
		${0}


#if-else-if
snippet ifelif
	if (${1})
		${2:${VISUAL}}
	else if (${3})
		${0:${VISUAL}}


snippet eif
	else if (${3})
		${0:${VISUAL}}


# while loop
snippet wh
	while (${1:obj}) {
		${0:${VISUAL}}
	}


# for loop(classic)
snippet for
	for (${1:item} <- ${2:obj}) {
		${0}
	}


#for loop(indexed)
snippet fori
	for (${1:i} <- ${2:0} to ${3:obj}.length) {
		${0}
	}


#for comprehension
snippet fory
	for {
		${1:item} <- ${2:obj}
		${3:item} <- ${4:obj}
		${5:item} <- ${6:obj}
	} yield ${0}


#exceptions
snippet try
	try {
		${1:${VISUAL}}
	} catch {
		case e: FileNotFoundException => ${2}
		case e: IOException => ${3}
	} finally {
		${0}
	}


#match
snippet mat
	${1:${VISUAL}} match {
		case ${2} => ${0}
	}


snippet match
	${1: obj} match {
		case ${2:e} => ${3}
		case _ => ${0}
	}


#case
snippet case
	case ${1:${VISUAL}} => ${0}


############################
# methods and arguments    #
############################

#arg
snippet arg
	${1:a}: ${2:T}${0:, arg}


#args
snippet args
	${1:args}: ${0:T}*


#def
snippet def
	def ${1:name}(${2:arg}) = ${0:}


#private def
snippet prdef
	private def ${1:name}(${2:arg}) = ${0:}


#override def
snippet ovdef
	override def ${1:name}(${2:arg}) = ${0:}


#first class function(see scalabook p 188)
snippet fcf
	(${1:a}: ${2:T}) => $1 ${0}


snippet =>
	${1:name} => ${0}


#recursion
snippet rec
	def ${1:name}(${0:arg}) =
		if($2) $2
		else $1($2)


#curried method
snippet crdef
	def ${1:name}(${2:arg})(${3:arg}) = ${0:}


#main method
#check validity of T
snippet main
	def main(args: Array[String]):${1:T} = ${0:}


#named snippets for types
snippet arr
	Array${1:[T]}${0:()}


snippet list
	List${1:[T]}${0:()}


snippet set
	Set${1:[T]}${0:()}


#for maps
snippet keyval
	${1:key}->${2:val}${0:, keyval}


snippet map
	Map[${1:T},${2:T}]${0:(keyval)}


snippet mmap
	mutable.Map[${1:T},${2:T}]${0:(keyval)}


#collections methods

#scope() with one arg
snippet (a
	(${1:a} => ${0})


#scope() with two args
snippet {(
	{(${1:a},${2:b}) =>
		${0}
	}


#filter
snippet filter
	${0:name}.filter (a

#map function

snippet mapf
	${0:name}.map (a


#flatmap
snippet flatmap
	${1:name}.flatMap${0:[T]}(a


#fold left
snippet fldl
	${1:name}.foldLeft(${0:first}) {(


#fold right
snippet fldr
	${1:name}.foldRight(${0:first}) {(


#fold left operator(if u wanna reduce readability of ur code)
#use wildcard symbols
snippet /:
	(${1:first}/:${2:name})(${0})


#fold right operator
snippet :\
	(${1:first}:\${2:name})(${0})


#reduce left
snippet redl
	${1:name}.reduceLeft[${0:T}] {(


#reduce right
snippet redr
	${1:name}.reduceRight[${0:T}] {(


#zipWithIndex(safe way).
#see http://daily-scala.blogspot.com/2010/05/zipwithindex.html
snippet zipwi
	${0:name}.view.zipWithIndex


#split
snippet spl
	${1:name}.split("${0:,}")


#end
snippet val
	val ${1:name}${2:: T} = ${0:value}


snippet var
	var ${1:name}${2:: T} = ${0:value}


############################
# classes
#
#extends
snippet extends
	extends ${0:what}


#with
snippet with
	with ${1:what}${0: with}


#auxiliary constructor(a. this)
snippet athis
	def this(arg) = this(arg)


#abstract class
snippet abstract
	abstract class ${1:name}${2:(arg)}${3: extends }${4: with} {
		${5:override def toString = "$1"}
		${0}
	}


#class
snippet class
	class ${1:name}${2:(arg)}${3: extends }${4: with} {
		${5:override def toString = "$1"}
		${0}
	}


#object
snippet object
	object ${1:name}${2:(arg)}${3: extends }${4: with} ${0:}


#trait
snippet trait
	trait ${1:name}${2: extends }${3: with} {
		${0:}
	}


#class with trait Ordered(page 265)
snippet ordered
	class ${1:name}${2:(arg)} extends Ordered[$1] ${3: with} {
		${4:override def toString = "$1"}
		def compare(that: $1) = ${5:this - that}
		${0}
	}


#case class
snippet casecl
	case class ${1:name}${2:(arg)}${3: extends }${4: with} ${0:}


############################
# testing
#
#scalatest imports
snippet scalatest
	${1:import org.scalatest.Suite}
	${0:import org.scalatest.FunSuite}


#assert
snippet assert
	assert(${1:a} === ${0:b})


#ensuring(p 296)
snippet ensuring
	ifel ensuring(${1:a}==${0:b})


#expect
snippet expect
	expect(${1:what}) {
		${0}
	}


#intercept
snippet intercept
	intercept[${1:IllegalArgumentException}] {
		${0}
	}


#test
snippet test
	test("${1:description}") {
		${0}
	}


#suite
snippet suite
	class ${0:name} extends Suite {
		def test() {
	}


#funsuite
snippet fsuite
	class ${1:name} extends FunSuite {
		test("${0:description}") {
	}


